### Day1

- 数据库及项目环境配置搭建
- 前端页面引入
- 开启静态资源映射->WebMvcConfig
- 员工实体类
- mapper->service接口->接口调用->控制层
- Tips:文档注释快捷键输入/** 按下Enter
- 编写通用的返回结果类，用来进行前后端的响应成功与失败
- > 登录逻辑
  >
  > 密码是md5加密，将页面提交的密码进行md5加密处理
  >
  > 根据页面提交的用户名查询数据库
  >
  > 查询失败则返回失败结果，查询成功则密码比对
  >
  > 查看员工状态，是否禁用。无禁用则登录成功，员工ID存入Session返回成功结果
- 登录功能开发完毕
- 登录退出逻辑->post退出然后清空session

### Day2

- 完善登录逻辑，问题：可以直接访问登录后的页面 解决：使用过滤器或拦截器
- > 创建登录过滤器
  >
  > 逻辑：获取申请的uri
  >
  > 判断请求是否要处理，如果是则判断登录状态，不是则跳转到登录页面
  >
  > 判断登录状态，已登录则放行，未登录则跳转到登录页面
  >
  > 注意：测试时，记得Ctrl+F5清空缓存
- 新增员工 ->查看索引username
- 新增的模式：基本上都是**请求+响应**
- 新增程序的流程：页面发送ajax请求，页面数据以json形式提交后端->后端控制层接受请求并调用Service保存->
  Service调用Mapper保存->给前端响应数据
- 全局异常处理器(关键点1.底层是代理，选择监控控制器 关键点2.选择处理的异常类型)
- 信息显示 分页查询展示 过滤查询
- > 分页查询过程
  >
  > 页面发ajax请求，参数（当前页，每页条数）提交后端
  >
  > 控制层接受请求，调用Service，传入参数，返回结果
  >
  > Service调用Mapper，传入参数，返回结果
  >
  > 控制层查询结果响应给页面，页面通过组件展示

### Day3

- 启用/禁用员工账号，管理员才能显示这个功能(动态页面条件渲染)`v-if="user === 'admin'"`
- 启用/禁用员工账号逻辑
- ajax请求发送逻辑：1.组件点击触发事件2.触发事件包含的方法调用3.方法内调用别的方法
- > 1.页面发ajax请求，参数提交后端
  >
  > 2.控制层接收数据调用Service，传入参数，返回结果
  >
  > 3.Service调用Mapper，传入参数，返回结果
  >
  > 4.控制层查询结果响应给页面，页面通过组件展示
- JSON格式数据->后端要加@RequestBody注解
- > 更新操作发现问题：JS处理数字类型（例如Long类型ID）时，会丢失精度，导致后端接收到的数据丢失精度，导致数据库更新失败
  >
  > 解决方法：对象映射器将Long类型转为String类型->转换器添加扩展到MVC配置类中
- > 编辑（更新）员工信息的代码逻辑：
  > 1.点击编辑按钮，跳转到编辑页面（和新增员工页面一样，是公共页面），并在url携带员工id
  >
  > Tips:url通过前端的js代码获取，然后切割出id(index.js)
  >
  > 2.页面获取员工id，发送ajax请求，提交id参数给后端
  >
  > 3.后端接收id，查询员工信息，将信息以json形式返回给页面
  >
  > 4.页面接收后端数据，用过VUE数据绑定进行信息回显
  >
  > 5.点击保存按钮，发送ajax请求，提交员工信息给后端
  >
  > 6.后端接收员工信息，进行处理，完成后给页面响应
  >
  > 7.页面接收后端响应，提示保存成功，跳转到员工列表页面
- PathVariable注解是获取url**路径**中的参数
- > 公共字段自动填充-MybatisPlus
  >
  > 实现步骤：1.实体类属性加@TableField注解，指定数据库字段名 2.按框架要求写元数据对象处理器，实现MetaObjectHandler接口
  >
  > 问题：自动填充用户ID时是固定的，需要改成动态的
  >
  > 解决方法：ThreadLocal
  >
  >
  ThreadLocal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
  >
  > ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
  >
  >
  我们可以在LoginCheckFilter的doFilter方法中获取当前登录用户id，并调用ThreadLocal的set方法来设置当前线程的线程局部变量的值（用户id)
  ，然后在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法来获得当前线程所对应的线程局部变量的值（用户id)。
  >
  > 实现步骤：1.写BaseContext工具类，基于ThreadLocal封装
  2.写LoginCheckFilter的doFilter方法，调用`BaseContext.setCurrentId(empId)`设置当前登录用户id
  3.在数据对象处理器的方法中调用BaseContext的getCurrentId方法获取当前登录用户id

### Day4

- 新增分类的开发，开发清单如下
-
    1. 实体类Category
    2. Mapper接口CategoryMapper
    3. 服务层接口CategoryService
    4. 服务层实现接口类CategoryServiceImpl
    5. 控制层类CategoryController
- 新增分类开发完毕
- 分类的分页查询开发完毕，与员工的区别：没有搜索条件字段
- 分页查询的需求分析：类别很多时，一个页面全部展示会显得比较乱，不方便查看
- 删除分类的需求分析：删除分类时，需要判断该分类下是否有菜品或套餐，如果有则不能删除
- 删除分类的开发步骤
    1. 页面发ajax请求，提交id参数给后端
    2. 后端控制层接收id，调用Service，传入id
    3. Service调用Mapper，传入id，删除数据
    4. **注意点**：控制层接收的字段名需要和页面url传的字段名相同（是ids而不是id）
- 删除分类的完善
    1. 实体类Dish和Setmeal
    2. Mapper接口DishMapper和SetmealMapper
    3. Service接口DishService和SetmealService
    4. Service实现类DishServiceImpl和SetmealServiceImpl
- 新增了一个自定义异常类，继承RuntimeException
- 分类服务层自定义了删除方法，删除分类时，判断该分类下是否有菜品或套餐，如果有则不能删除
- 全局异常处理新增了自定义异常类的捕获
- 编辑分类的功能开发

### Day5

- 文件上传和下载
- 上传要求：form表单需要采用post方式提交、采用multipart格式上传文件、使用input的file控件上传
- 服务端处理上传文件通常使用Apache的Commons FileUpload组件、commons io组件
- spring框架对文件上传进行了封装，只需要在控制层声明MultipartFile类型参数即可
- 文件下载形式1.以附件形式下载，文件保存到本地磁盘目录2.直接在浏览器打开
- > 上传的后端编写注意：
  > 1. MultipartFile参数名字必须和组件的name属性一致。
  > 2. 文件是临时上传，需要转存到指定位置，指定位置需要确保目录存在，不存在则创建。
  > 3. 文件名需要使用UUID重命名防止重复覆盖。
- > 下载的后端开发步骤：
  > 1. 创建文件输入流，读取文件内容
  > 2. 创建输出流，将文件内容写入到响应输出流中，并写回浏览器显示
  > 3. 设置响应内容的图像类型
  > 4. 读取文件内容并写入输出流
  > 5. 关闭资源
- 新增菜品设计数据库表dish、dish_flavor（菜品口味）
- > 新增菜品开发结构
  > 1. 实体类Dish、DishFlavor
  > 2. Mapper接口DishMapper、DishFlavorMapper
  > 3. 服务层接口DishService、DishFlavorService
  > 4. 服务层实现类DishServiceImpl、DishFlavorServiceImpl
  > 5. 控制层类DishController
- > 新增菜品的前后端交互过程
  > 1. 页面发ajax请求，请求后端获取菜品分类数据展示到下拉框
  > 2. 页面发请求进行图片上传，请求后端将图片保存到服务器
  > 3. 页面发送请求进行图片下载，上传的图片进行回显
  > 4. 点击保存按钮，发送ajax请求，提交json数据给后端